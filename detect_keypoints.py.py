# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ddk_8TJObvU6JgCH6MntZToCRLMJoqU1
"""



import json
import os
import cv2
import numpy as np
import matplotlib.pyplot as plt

def extract_and_display_iris_images(json_folder, image_folder, output_folder):
    os.makedirs(output_folder, exist_ok=True)

    for json_file in os.listdir(json_folder):
        if json_file.endswith(".json"):
            json_path = os.path.join(json_folder, json_file)
            with open(json_path) as f:
                item = json.load(f)

            image_file = item['imagePath']
            image_path = os.path.join(image_folder, image_file)
            image = cv2.imread(image_path)

            if image is None:
                print(f"Warning: Image {image_path} not found. Skipping.")
                continue

            height, width, _ = image.shape
            mask = np.zeros((height, width), dtype=np.uint8)

            for shape in item['shapes']:
                if shape['shape_type'] == 'circle' and shape['label'].lower() == 'iris':
                    center = (int(shape['points'][0][0]), int(shape['points'][0][1]))
                    radius = int(np.linalg.norm(np.array(shape['points'][0]) - np.array(shape['points'][1])))
                    cv2.circle(mask, center, radius, 1, -1)  # Fill the circle for iris

            iris_image = cv2.bitwise_and(image, image, mask=mask)
            iris_image_path = os.path.join(output_folder, os.path.splitext(image_file)[0] + "_iris.png")
            cv2.imwrite(iris_image_path, iris_image)

            # Display the original and iris images
            plt.figure(figsize=(10, 5))

            # Display the original image
            plt.subplot(1, 2, 1)
            plt.title('Original Image')
            plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
            plt.axis('off')

            # Display the iris image
            plt.subplot(1, 2, 2)
            plt.title('Iris Image')
            plt.imshow(cv2.cvtColor(iris_image, cv2.COLOR_BGR2RGB))
            plt.axis('off')

            plt.show()

            print(f"Processed: {image_file}")

# Example usage
json_folder = '/content/gdrive/MyDrive/Annotation'
image_folder = '/content/gdrive/MyDrive/zoomed_in_eyes'
output_folder = '/content/drive/MyDrive/iris_images'
extract_and_display_iris_images(json_folder, image_folder, output_folder)

import os
from PIL import Image, UnidentifiedImageError
import numpy as np
import cv2
import matplotlib.pyplot as plt

# Path to the images
image_path = '/content/drive/MyDrive/iris_images'
output_path = '/content/drive/MyDrive/iris_images_preprocessed'

# Create the output directory if it doesn't exist
if not os.path.exists(output_path):
    os.makedirs(output_path)

# Load images
def load_images_from_folder(folder):
    images = []
    filenames = []
    valid_extensions = ('.jpg', '.jpeg', '.png', '.bmp', '.tiff')
    for filename in os.listdir(folder):
        if filename.lower().endswith(valid_extensions):
            try:
                img = Image.open(os.path.join(folder, filename))
                images.append(img)
                filenames.append(filename)
            except (IOError, UnidentifiedImageError) as e:
                print(f"Skipping file {filename}: {e}")
    return images, filenames

images, filenames = load_images_from_folder(image_path)

# Resize images
def resize_images(images, size=(224, 224)):
    resized_images = [img.resize(size, Image.LANCZOS) for img in images]
    return resized_images

resized_images = resize_images(images)

# Reduce noise
def reduce_noise(images):
    denoised_images = []
    for img in images:
        img_array = np.array(img)
        denoised_img = cv2.GaussianBlur(img_array, (5, 5), 0)
        denoised_images.append(Image.fromarray(denoised_img))
    return denoised_images

denoised_images = reduce_noise(resized_images)

# Enhance contrast
def enhance_contrast(images):
    enhanced_images = []
    for img in images:
        img_array = np.array(img)
        lab = cv2.cvtColor(img_array, cv2.COLOR_RGB2LAB)
        l, a, b = cv2.split(lab)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        cl = clahe.apply(l)
        limg = cv2.merge((cl, a, b))
        final_img = cv2.cvtColor(limg, cv2.COLOR_LAB2RGB)
        enhanced_images.append(Image.fromarray(final_img))
    return enhanced_images

enhanced_images = enhance_contrast(denoised_images)

# Save preprocessed images
def save_images(images, filenames, folder):
    for img, filename in zip(images, filenames):
        img.save(os.path.join(folder, filename))

save_images(enhanced_images, filenames, output_path)

# Display before and after images (optional)
def display_images(before, after, filenames):
    for i in range(len(before)):
        plt.figure(figsize=(10, 5))

        plt.subplot(1, 2, 1)
        plt.title(f'Original - {filenames[i]}')
        plt.imshow(before[i])
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.title(f'Processed - {filenames[i]}')
        plt.imshow(after[i])
        plt.axis('off')

        plt.show()

# Displaying a few images to verify (optional)
display_images(images[:5], enhanced_images[:5], filenames[:5])



import cv2
import numpy as np
import os
from matplotlib import pyplot as plt

# Path to the preprocessed images
input_path = '/content/gdrive/MyDrive/iris_images_preprocessed'
output_path = '/content/drive/MyDrive/keypoints_of_the_iris'

# Create the output directory if it doesn't exist
if not os.path.exists(output_path):
    os.makedirs(output_path)

# Create a binary mask to exclude the pupil
def create_mask(image, center, radius):
    mask = np.ones_like(image) * 255
    cv2.circle(mask, center, radius, (0, 0, 0), -1)
    return mask

# Process each image in the input directory
def process_images(input_path, output_path, pupil_radius=50):
    filenames = [f for f in os.listdir(input_path) if f.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp', '.tiff'))]
    for filename in filenames:
        image_path = os.path.join(input_path, filename)
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

        # Calculate the center of the pupil (assume center of the image)
        center = (image.shape[1] // 2, image.shape[0] // 2)

        # Create mask
        mask = create_mask(image, center, pupil_radius)

        # Detect keypoints using SIFT with mask
        sift = cv2.SIFT_create(nfeatures=500, contrastThreshold=0.04, edgeThreshold=10)
        keypoints, descriptors = sift.detectAndCompute(image, mask)

        # Print the coordinates and details of the keypoints
        print(f"Keypoints for {filename}:")
        for kp in keypoints:
            print(f"Coordinate: ({kp.pt[0]:.2f}, {kp.pt[1]:.2f}), Size: {kp.size:.2f}, Angle: {kp.angle:.2f}")

        # Draw keypoints on the image
        image_with_keypoints = cv2.drawKeypoints(image, keypoints, None, flags=cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)

        # Save the image with keypoints to the output directory
        output_image_path = os.path.join(output_path, filename)
        cv2.imwrite(output_image_path, image_with_keypoints)

        # Display the original image, mask, and image with keypoints
        plt.figure(figsize=(15, 5))

        plt.subplot(1, 3, 1)
        plt.title('Original Image')
        plt.imshow(image, cmap='gray')
        plt.axis('off')

        plt.subplot(1, 3, 2)
        plt.title('Mask')
        plt.imshow(mask, cmap='gray')
        plt.axis('off')

        plt.subplot(1, 3, 3)
        plt.title('Image with Keypoints')
        plt.imshow(image_with_keypoints)
        plt.axis('off')

        plt.show()

# Process images and save outputs
process_images(input_path, output_path, pupil_radius=50)